---
title: "MCP Tool: KnowledgeStore Server Architecture"
description: "Detailed architecture for the Nucleus_KnowledgeStore_McpServer, outlining its purpose, MCP operations for managing ArtifactMetadata and PersonaKnowledgeEntry records, core logic, dependencies, and security model."
version: 1.1 # Incremented version
date: 2025-05-28 # Updated date
parent: ../01_MCP_TOOLS_OVERVIEW.md
see_also:
  - title: "MCP Tools Overview"
    link: "../01_MCP_TOOLS_OVERVIEW.md"
  - title: "Comprehensive System Architecture"
    link: "../../NorthStarDocs/01_NUCLEUS_SYSTEM_ARCHITECTURE_COMPREHENSIVE_GUIDE.md" # Corrected link
  - title: "Data Persistence Strategy"
    link: "../../CoreNucleus/03_DATA_PERSISTENCE_STRATEGY.md"
  - title: "Core Abstractions, DTOs, and Interfaces"
    link: "../../CoreNucleus/06_ABSTRACTIONS_DTOs_INTERFACES.md"
  - title: "Security Overview and Governance"
    link: "../../Security/01_SECURITY_OVERVIEW_AND_GOVERNANCE.md"
  - title: "Foundations: MCP & M365 Agents SDK"
    link: "../../NorthStarDocs/00_FOUNDATIONS_TECHNOLOGY_PRIMER.md" # Corrected link
---

# MCP Tool: KnowledgeStore Server Architecture (`Nucleus_KnowledgeStore_McpServer`)

## 1. Purpose and Core Responsibilities

The `Nucleus_KnowledgeStore_McpServer` (referred to as KnowledgeStore MCP Server) is a foundational backend Model Context Protocol (MCP) tool within the Nucleus ecosystem.

*   **Primary Goal:** To serve as the exclusive and authoritative gateway for all interactions with the Nucleus persistent data store, which is Azure Cosmos DB. It is responsible for managing `ArtifactMetadata` and `PersonaKnowledgeEntry` records.
*   **Capabilities Encapsulated:** This server encapsulates all logic for Create, Read, Update, and Delete (CRUD) operations for both `ArtifactMetadata` and `PersonaKnowledgeEntry` DTOs. It also provides robust vector search capabilities over `PersonaKnowledgeEntry` records and allows for querying these records based on various metadata fields.
*   **Contribution to M365 Agents:** The KnowledgeStore MCP Server provides Nucleus M365 Persona Agents with a secure, standardized, and auditable mechanism to:
    *   Store descriptive metadata about source artifacts (e.g., files, messages) they encounter or process (`ArtifactMetadata`).
    *   Persist derived knowledge, analyses, insights, and text embeddings generated by the persona's AI models (`PersonaKnowledgeEntry`).
    *   Retrieve relevant `ArtifactMetadata` and `PersonaKnowledgeEntry` records to hydrate context, inform their reasoning, and generate grounded responses.
    *   Perform semantic (vector-based) searches over stored persona knowledge to find the most relevant information for a given query.

This MCP server ensures data integrity, enforces tenant isolation, and abstracts the complexities of direct database interaction from the M365 Persona Agents.

## 2. Key MCP Operations / Tools Exposed

The KnowledgeStore MCP Server exposes several MCP operations (tools) that M365 Persona Agents can invoke. These operations are designed to be granular and adhere to the Model Context Protocol specifications. All operations require a validated `TenantId` from the authenticated caller.

*   **`KnowledgeStore.SaveArtifactMetadata`**
    *   **Description:** Saves a new `ArtifactMetadata` record or updates an existing one. This is typically called by an M365 Persona Agent after it has identified or processed a source artifact (e.g., a file shared in Teams).
    *   **Input Parameters (DTO):** `SaveArtifactMetadataRequest { ArtifactMetadata artifact, string TenantId }` (referencing `Nucleus.Shared.Kernel.Abstractions.Models.ArtifactMetadata`).
    *   **Output/Return Value (DTO):** `ConfirmationResponse { bool Success, string Id, string? ErrorMessage }`. The `Id` returned is the unique Nucleus ID for the `ArtifactMetadata` record.
    *   **Idempotency:** The operation is an upsert. If an `Id` is provided in the `ArtifactMetadata` DTO and it exists for the given `TenantId`, it's updated. Otherwise, a new record is created. Uniqueness can also be enforced based on a combination of `SourcePlatformIdentifier` and `SourceArtifactId` within a `TenantId` if no `Id` is provided.

*   **`KnowledgeStore.GetArtifactMetadataById`**
    *   **Description:** Retrieves a specific `ArtifactMetadata` record by its unique Nucleus ID.
    *   **Input Parameters (DTO):** `GetByIdRequest { string Id, string TenantId }`.
    *   **Output/Return Value (DTO):** `GetArtifactMetadataResponse { ArtifactMetadata? Metadata }` (or `ArtifactMetadata?` directly). Returns `null` or an empty response if not found or not authorized.

*   **`KnowledgeStore.SearchArtifactMetadata`**
    *   **Description:** Searches `ArtifactMetadata` records based on a flexible set of criteria, such as tags, source platform, date ranges, artifact type, etc.
    *   **Input Parameters (DTO):** `MetadataSearchRequest { string TenantId, ArtifactMetadataFilters Filters, PagingOptions Paging }` (referencing `Nucleus.Shared.Kernel.Abstractions.Models.Searching`).
    *   **Output/Return Value (DTO):** `PagedResult<ArtifactMetadata>`.

*   **`KnowledgeStore.SavePersonaKnowledgeEntry`**
    *   **Description:** Saves a new `PersonaKnowledgeEntry` record or updates an existing one. This is called by M365 Persona Agents after they have analyzed content and derived specific knowledge, insights, or generated embeddings.
    *   **Input Parameters (DTO):** `SavePkeRequest { PersonaKnowledgeEntry Entry, string TenantId }` (referencing `Nucleus.Shared.Kernel.Abstractions.Models.PersonaKnowledgeEntry`). The `Entry` DTO includes `TenantId` (validated against request), `PersonaId`, `ArtifactId` (linking to `ArtifactMetadata`), `EmbeddingVector`, `AnalysisData`, etc.
    *   **Output/Return Value (DTO):** `ConfirmationResponse { bool Success, string Id, string? ErrorMessage }`. The `Id` is the unique Nucleus ID for the `PersonaKnowledgeEntry`.
    *   **Idempotency:** Upsert based on `Id`. Uniqueness can also be based on a combination of `ArtifactId` and `PersonaId` within a `TenantId`.

*   **`KnowledgeStore.GetPersonaKnowledgeEntryById`**
    *   **Description:** Retrieves a specific `PersonaKnowledgeEntry` by its unique Nucleus ID.
    *   **Input Parameters (DTO):** `GetByIdRequest { string Id, string TenantId }`.
    *   **Output/Return Value (DTO):** `GetPkeResponse { PersonaKnowledgeEntry? Entry }` (or `PersonaKnowledgeEntry?` directly).

*   **`KnowledgeStore.SearchPersonaKnowledgeByVector`**
    *   **Description:** Performs a vector similarity search against `PersonaKnowledgeEntry` records for a given `TenantId` and optionally a specific `PersonaId`.
    *   **Input Parameters (DTO):** `VectorSearchRequest { string TenantId, string? PersonaId, List<float> QueryVector, int TopK, KnowledgeSearchFilters? Filters }` (referencing `Nucleus.Shared.Kernel.Abstractions.Models.Searching`).
    *   **Output/Return Value (DTO):** `PagedResult<PersonaKnowledgeEntry>` (ranked by similarity score).

*   **`KnowledgeStore.GenerateEmbeddingsAndSavePKE`** (Composite Operation)
    *   **Description:** A higher-level operation that accepts a `PersonaKnowledgeEntry` containing raw text snippets (e.g., in `AnalysisData` or a dedicated field). The MCP server internally generates text embeddings for these snippets using its configured `ITextEmbeddingGenerator` and then saves the complete `PersonaKnowledgeEntry` (with the generated `EmbeddingVector`) to the database.
    *   **Input Parameters (DTO):** `PkeWithTextForEmbeddingRequest { string TenantId, string PersonaId, string ArtifactId, List<string> TextSnippetsToEmbed, JsonElement? AnalysisData, /* other PKE fields */ }`.
    *   **Output/Return Value (DTO):** `ConfirmationResponse { bool Success, string Id, string? ErrorMessage }`.

Error handling for all operations will involve returning a standardized error DTO as part of the MCP response if `Success` is `false`, including an error code and message.

## 3. Core Internal Logic & Components

The KnowledgeStore MCP Server's internal architecture is built around clear separation of concerns:

*   **MCP Handler Layer:** Receives incoming MCP requests, deserializes them, validates inputs (including `TenantId` from the authenticated token), and routes them to appropriate service logic.
*   **Service Layer:** Contains the core business logic for each operation. This layer orchestrates calls to repository interfaces and other internal components like embedding generators.
*   **Repository Implementation:**
    *   The server implements the `IArtifactMetadataRepository` and `IPersonaKnowledgeRepository` interfaces defined in `Nucleus.Shared.Kernel.Abstractions.Data`.
    *   These implementations directly utilize the `Nucleus.Infrastructure.CosmosDb` library to interact with Azure Cosmos DB. This library handles the specifics of Cosmos DB queries, item creation, updates, and vector search execution.
*   **Tenant ID Enforcement:** A critical aspect of the internal logic is the strict enforcement of `tenantId` scoping for ALL database operations. The `tenantId` extracted from the validated MCP caller's token is used as a mandatory filter or partition key in every Cosmos DB query and operation to ensure data isolation.
*   **Vector Index Management:** While Cosmos DB handles the underlying vector indexing, this server's logic ensures that `EmbeddingVector` fields are correctly populated and structured for indexing when saving `PersonaKnowledgeEntry` records.
*   **Embedding Generation (for `GenerateEmbeddingsAndSavePKE`):**
    *   If this composite operation is invoked, the server uses an injected instance of `ITextEmbeddingGenerator` (from `Microsoft.Extensions.AI.Embeddings`).
    *   This generator is configured at the MCP server level (see Deployment & Configuration) to use a specific LLM provider and embedding model.

## 4. Dependencies

The KnowledgeStore MCP Server relies on the following services and libraries:

*   **Azure Services:**
    *   **Azure Cosmos DB:** The primary dependency for NoSQL data storage and integrated Vector Search capabilities. Used to store `ArtifactMetadata` and `PersonaKnowledgeEntry` containers.
    *   **Azure Key Vault:** Used to securely store sensitive configuration values, such as the Azure Cosmos DB connection string and any API keys required for its own embedding generation service (if applicable). Accessed via Managed Identity.
    *   **Azure App Configuration (Optional but Recommended):** For managing non-sensitive operational configurations.
*   **External Services/LLMs (Conditional):**
    *   If the `GenerateEmbeddingsAndSavePKE` operation is supported and utilized, this MCP server will have a dependency on a configured LLM provider (e.g., Azure OpenAI, Google Gemini) for generating text embeddings. This interaction is managed via the `Microsoft.Extensions.AI` abstractions.
*   **Other Nucleus MCP Tools:**
    *   This server is a foundational data service and is **unlikely to call other Nucleus MCP tools directly**. It serves requests from M365 Persona Agents.
*   **Shared Nucleus Libraries:**
    *   `Nucleus.Shared.Kernel.Abstractions`: Essential for DTOs (like `ArtifactMetadata`, `PersonaKnowledgeEntry`, request/response models), repository interfaces (`IArtifactMetadataRepository`, `IPersonaKnowledgeRepository`), and common models.
    *   `Nucleus.Infrastructure.CosmosDb`: Provides the concrete implementation for interacting with Azure Cosmos DB, abstracting SDK-specific details.
    *   `Microsoft.Extensions.AI`: Used if the server performs its own embedding generation, providing abstractions like `ITextEmbeddingGenerator`.
    *   Standard ASP.NET Core libraries for building the MCP service endpoint.

## 5. Security Model

Security is a cornerstone of the KnowledgeStore MCP Server, ensuring that only authorized M365 Persona Agents can access and manipulate data, and only within their designated tenant.

*   **Authentication of Callers (M365 Persona Agents):**
    *   Incoming MCP requests from M365 Persona Agents **must** be authenticated using Azure Active Directory (Azure AD) OAuth 2.0 bearer tokens.
    *   The KnowledgeStore MCP Server (an ASP.NET Core application) is configured as a protected web API. It validates the incoming token, checking:
        *   **Signature:** Ensures the token was issued by a trusted authority (Azure AD).
        *   **Audience (`aud` claim):** Verifies the token was intended for this specific KnowledgeStore MCP Server (using its unique Application ID URI).
        *   **Issuer (`iss` claim):** Confirms the token was issued by the correct Azure AD tenant(s).
        *   **App ID (`appid` or `azp` claim):** Identifies the calling M365 Persona Agent's application.
*   **Authorization within the Tool:**
    *   **Tenant Isolation:** The `tid` (tenant ID) claim from the validated Azure AD token is extracted. This `tid` is **mandatory** and is used as the primary key for data partitioning and filtering in all Cosmos DB operations. An agent can only operate on data associated with its own tenant.
    *   **App Role-Based Access Control (RBAC):**
        *   The KnowledgeStore MCP Server can define application roles (e.g., `Knowledge.Read`, `Knowledge.Write`, `Knowledge.Admin`).
        *   Calling M365 Persona Agents' service principals are granted these roles.
        *   The MCP server checks for the presence of required roles in the validated token before authorizing specific operations (e.g., a read-only agent might only have `Knowledge.Read`).
*   **Authentication to Dependencies:**
    *   The KnowledgeStore MCP Server itself uses its **Azure Managed Identity** to authenticate to other Azure services:
        *   **Azure Cosmos DB:** The Managed Identity is granted appropriate RBAC roles on the Cosmos DB account (e.g., "Cosmos DB Built-in Data Contributor") to perform data operations. Connection strings are avoided in favor of token-based authentication.
        *   **Azure Key Vault:** The Managed Identity is granted permissions (e.g., "Key Vault Secrets User") to retrieve secrets like the Cosmos DB endpoint details (if not using RBAC for data plane access directly) or API keys for its embedding service.

## 6. Data Handling & Persistence

This section details how the KnowledgeStore MCP Server interacts with its persistent store, Azure Cosmos DB.

*   **Database Interaction:** All data persistence is handled through Azure Cosmos DB, leveraging its NoSQL API and integrated vector indexing capabilities.
*   **Containers:**
    *   **`ArtifactMetadataContainer`:**
        *   Stores `ArtifactMetadata` documents.
        *   **Partition Key:** `tenantId`. This is crucial for scalability and strict data isolation.
    *   **`PersonaKnowledgeContainer`:**
        *   Stores `PersonaKnowledgeEntry` documents.
        *   **Partition Key:** `tenantId`. (Alternatively, a composite key like `tenantId_personaId` could be considered if queries are frequently scoped to a specific persona within a tenant, but `tenantId` alone is a strong primary choice).
*   **Indexing Strategy:**
    *   **`ArtifactMetadataContainer`:** Indexed on `tenantId` (partition key), and other commonly queried fields like `SourcePlatformIdentifier`, `SourceArtifactId`, `Tags`, `ArtifactType`, `Timestamp`.
    *   **`PersonaKnowledgeContainer`:**
        *   Indexed on `tenantId` (partition key), `personaId`, `artifactId`.
        *   **Vector Indexing:** A vector index is configured on the `EmbeddingVector` property (an array of floats) within `PersonaKnowledgeEntry` documents. This utilizes Cosmos DB's integrated vector search capabilities (e.g., HNSW or IVF for approximate nearest neighbor search). The specific vector index configuration (metric type like cosine, dimensions) is defined at the container level.
*   **Data Isolation:** As emphasized previously, data isolation is paramount. The validated `tenantId` from the authenticated MCP request is programmatically injected as the partition key value in **all** Cosmos DB operations (queries, reads, writes, deletes). This ensures that one tenant cannot accidentally or maliciously access another tenant's data.

## 7. Deployment & Configuration Considerations

The KnowledgeStore MCP Server is designed for cloud-native deployment, typically as a containerized application.

*   **Deployment Environment:** Typically deployed as an **Azure Container App** or an Azure App Service for containers. This provides scalability, managed infrastructure, and easy integration with other Azure services.
*   **Configuration Management:** Configurations are managed externally and securely, promoting the Twelve-Factor App methodology.
    *   **Azure App Configuration:** Used for non-sensitive settings (e.g., Cosmos DB database name, container names, default `TopK` for search).
    *   **Azure Key Vault:** Used for all sensitive settings. The MCP server's Managed Identity is granted access to retrieve these secrets.
        *   `CosmosDbConnectionStringSecretName` (or `CosmosDbEndpoint` if using AAD auth for data plane).
        *   If applicable for `GenerateEmbeddingsAndSavePKE`: `EmbeddingLLMApiKeySecretName`, `EmbeddingLLMEndpointUrl`.
*   **Key Configuration Parameters:**
    *   Cosmos DB Account Endpoint.
    *   Cosmos DB Database Name.
    *   `ArtifactMetadataContainerName`.
    *   `PersonaKnowledgeContainerName`.
    *   Vector index configuration parameters (if not fully managed by `Nucleus.Infrastructure.CosmosDb` based on conventions).
    *   If embedding generation is self-contained:
        *   `EmbeddingProvider` (e.g., "AzureOpenAI", "GoogleGemini").
        *   `EmbeddingModelId`.
        *   `EmbeddingApiKeySecretName` (if API key auth is used by the embedding provider).
        *   `EmbeddingProviderEndpointUrl` (if applicable).
*   **Scaling:** Azure Container Apps allow for scaling based on HTTP traffic or other KEDA scalers, suitable for the request-based nature of an MCP server. Cosmos DB itself offers elastic scalability.

## 8. Future Considerations / Potential Enhancements

While the current design provides a robust foundation, several enhancements could be considered for future iterations:

*   **Advanced Query Capabilities:**
    *   Support for more complex filtering and faceting in search operations.
    *   If the data model evolves to include more explicit relationships, consider exposing graph-like query capabilities (potentially leveraging Cosmos DB's Gremlin API if appropriate, though this would be a significant architectural shift).
*   **Azure Cosmos DB Change Feed Integration:**
    *   Expose MCP operations that allow M365 Persona Agents or other authorized backend services to subscribe to changes in the `ArtifactMetadata` or `PersonaKnowledgeContainer` (e.g., new entries, updates). This could enable real-time notifications, cache invalidation, or trigger downstream workflows.
*   **Soft Delete and Versioning:** Implement soft delete for records and potentially versioning for `ArtifactMetadata` or `PersonaKnowledgeEntry` to allow rollback or audit trails.
*   **Bulk Operations:** Introduce MCP operations for bulk saving or retrieving records to improve efficiency for large data transfers.
*   **Cross-Tenant Data Sharing (Controlled):** For specific, highly controlled scenarios, explore mechanisms for secure, consent-based sharing of anonymized or aggregated knowledge across tenant boundaries, if a valid use case emerges. This would require significant security and privacy considerations.
