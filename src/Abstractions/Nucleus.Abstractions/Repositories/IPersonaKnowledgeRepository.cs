using Nucleus.Abstractions.Models; // Assuming PersonaKnowledgeEntry will be in Models
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Nucleus.Abstractions.Repositories;

/// <summary>
/// Defines the contract for a repository responsible for managing PersonaKnowledgeEntry records
/// specific to a particular Persona and its analysis data type.
/// Implementations will typically interact with a dedicated {PersonaId}KnowledgeContainer in Cosmos DB.
/// See: ../../Docs/Architecture/04_ARCHITECTURE_DATABASE.md#4-personaidknowledgecontainer-schema
/// See: ../../Docs/Architecture/04_ARCHITECTURE_DATABASE.md#7-next-steps
/// </summary>
/// <typeparam name="TAnalysisData">The specific type of analysis data generated and stored by the Persona.</typeparam>
public interface IPersonaKnowledgeRepository<TAnalysisData>
{
    /// <summary>
    /// Retrieves a single PersonaKnowledgeEntry record by its unique ID within its container.
    /// </summary>
    /// <param name="id">The unique ID of the knowledge entry.</param>
    /// <param name="partitionKey">The partition key (e.g., artifactId, tenantId, or userId) required for the Cosmos DB query.</param>
    /// <returns>The found PersonaKnowledgeEntry record, or null if not found.</returns>
    Task<PersonaKnowledgeEntry<TAnalysisData>?> GetByIdAsync(string id, string partitionKey);

    /// <summary>
    /// Retrieves all PersonaKnowledgeEntry records associated with a specific artifact ID.
    /// </summary>
    /// <param name="artifactId">The ID of the artifact whose knowledge entries are to be retrieved.</param>
    /// <param name="partitionKey">The partition key strategy might require passing artifactId, tenantId or userId here depending on container setup.</param>
    /// <returns>An enumerable collection of PersonaKnowledgeEntry records.</returns>
    Task<IEnumerable<PersonaKnowledgeEntry<TAnalysisData>>> GetByArtifactIdAsync(string artifactId, string partitionKey);

    /// <summary>
    /// Creates or updates a PersonaKnowledgeEntry record in the repository.
    /// Implementations should handle setting relevant timestamps.
    /// </summary>
    /// <param name="entry">The PersonaKnowledgeEntry record to save.</param>
    /// <returns>The saved PersonaKnowledgeEntry record.</returns>
    Task<PersonaKnowledgeEntry<TAnalysisData>> SaveAsync(PersonaKnowledgeEntry<TAnalysisData> entry);

    /// <summary>
    /// Deletes a PersonaKnowledgeEntry record by its unique ID.
    /// </summary>
    /// <param name="id">The unique ID of the knowledge entry to delete.</param>
    /// <param name="partitionKey">The partition key required for the Cosmos DB delete operation.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    Task DeleteAsync(string id, string partitionKey);

    // Potential future methods for querying based on analysis data properties or vector search
    // Task<IEnumerable<PersonaKnowledgeEntry<TAnalysisData>>> FindByAnalysisPropertyAsync(string propertyName, object value, string partitionKey);
    // Task<IEnumerable<(PersonaKnowledgeEntry<TAnalysisData> Entry, double Score)>> FindSimilarAsync(float[] embedding, int topK, string partitionKey);
}


/// <summary>
/// Represents a knowledge entry generated by a Persona's analysis of an artifact.
/// Stored in a dedicated {PersonaId}KnowledgeContainer in Cosmos DB.
/// See: ../../Docs/Architecture/04_ARCHITECTURE_DATABASE.md#4-personaidknowledgecontainer-schema
/// </summary>
/// <typeparam name="TAnalysisData">The specific type of analysis data.</typeparam>
public record PersonaKnowledgeEntry<TAnalysisData>
{
    /// <summary>
    /// Unique identifier for the knowledge entry within its container.
    /// </summary>
    public required string Id { get; init; }

    /// <summary>
    /// ID of the ArtifactMetadata record this knowledge entry pertains to.
    /// </summary>
    public required string ArtifactId { get; init; }

    /// <summary>
    /// ID of the Persona that generated this knowledge entry.
    /// </summary>
    public required string PersonaId { get; init; }

    /// <summary>
    /// Tenant ID associated with the original artifact.
    /// </summary>
    public required string TenantId { get; init; }

    /// <summary>
    /// User ID associated with the original artifact context.
    /// </summary>
    public required string UserId { get; init; }

    /// <summary>
    /// Timestamp when this knowledge entry was created.
    /// </summary>
    public DateTimeOffset CreatedAt { get; init; } = DateTimeOffset.UtcNow;

    /// <summary>
    /// The actual analysis data generated by the persona.
    /// </summary>
    public required TAnalysisData AnalysisData { get; init; }

    /// <summary>
    /// A summary of the analysis, potentially used for quick previews or RAG.
    /// </summary>
    public string? AnalysisSummary { get; init; }

    /// <summary>
    /// Vector embedding of the AnalysisSummary.
    /// </summary>
    public float[]? AnalysisSummaryEmbedding { get; init; }

    /// <summary>
    /// The model used to generate the AnalysisSummaryEmbedding.
    /// </summary>
    public string? AnalysisSummaryEmbeddingModel { get; init; }

    /// <summary>
    /// Relevant text snippets extracted from the artifact during analysis, with embeddings.
    /// </summary>
    public List<RelevantSnippet> RelevantTextSnippets { get; init; } = [];

    // Consider adding PartitionKey property similar to ArtifactMetadata if needed
    // public string PartitionKey => ArtifactId; // Example: Partition by ArtifactId
}

/// <summary>
/// Represents a relevant text snippet extracted by a Persona, along with its embedding.
/// </summary>
public record RelevantSnippet
{
    /// <summary>
    /// The extracted text content.
    /// </summary>
    public required string Text { get; init; }

    /// <summary>
    /// Vector embedding of the text snippet.
    /// </summary>
    public required float[] Embedding { get; init; }

    /// <summary>
    /// The model used to generate the embedding.
    /// </summary>
    public required string EmbeddingModel { get; init; }

    /// <summary>
    /// Optional: Identifier for the source location within the original artifact (e.g., page, timestamp).
    /// </summary>
    public string? SourceLocation { get; init; }
}
