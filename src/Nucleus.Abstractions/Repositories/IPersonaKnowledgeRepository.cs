using Nucleus.Abstractions.Models; // Kept for potential future use or if needed by generics implicitly.
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Nucleus.Abstractions.Repositories;

/// <summary>
/// Enum representing the confidence level of the persona's analysis.
/// @TODO: I'm not in love with this location for the enum definition. Anywhere that we can make this more globally available like NucleusConstants.cs?
/// </summary>
public enum ConfidenceLevel
{
    Unknown = 0,
    VeryLow = 1,
    Low = 2,
    Medium = 3,
    High = 4,
    VeryHigh = 5,
    Certain = 6
}

/// <summary>
/// Defines the contract for storing and retrieving persona-specific knowledge entries.
/// These entries represent the processed output or analysis derived from artifacts by a specific persona.
/// Implementations will typically interact with a persistent data store (e.g., Cosmos DB).
/// </summary>
/// <typeparam name="TAnalysisData">The type of the specific analysis data stored within the knowledge entry.</typeparam>
/// <seealso cref="Models.PersonaKnowledgeEntry{TAnalysisData}"/>
/// <seealso cref="../../../../../Docs/Architecture/00_ARCHITECTURE_OVERVIEW.md"/>
/// <seealso cref="../../../../../Docs/Architecture/01_ARCHITECTURE_PROCESSING.md"/>
/// <seealso cref="../../../../../Docs/Architecture/02_ARCHITECTURE_PERSONAS.md"/>
/// <seealso cref="../../../../../Docs/Architecture/04_ARCHITECTURE_DATABASE.md"/>
public interface IPersonaKnowledgeRepository<TAnalysisData>
{
    /// <summary>
    /// Retrieves a single PersonaKnowledgeEntry record by its unique ID within its container.
    /// </summary>
    /// <param name="id">The unique ID of the knowledge entry.</param>
    /// <param name="partitionKey">The partition key (e.g., artifactId, tenantId, or userId) required for the Cosmos DB query.</param>
    /// <returns>The found PersonaKnowledgeEntry record, or null if not found.</returns>
    Task<PersonaKnowledgeEntry<TAnalysisData>?> GetByIdAsync(string id, string partitionKey);

    /// <summary>
    /// Retrieves all PersonaKnowledgeEntry records associated with a specific artifact ID.
    /// </summary>
    /// <param name="artifactId">The ID of the artifact whose knowledge entries are to be retrieved.</param>
    /// <param name="partitionKey">The partition key strategy might require passing artifactId, tenantId or userId here depending on container setup.</param>
    /// <returns>An enumerable collection of PersonaKnowledgeEntry records.</returns>
    Task<IEnumerable<PersonaKnowledgeEntry<TAnalysisData>>> GetByArtifactIdAsync(string artifactId, string partitionKey);

    /// <summary>
    /// Creates or updates a PersonaKnowledgeEntry record in the repository.
    /// Implementations should handle setting relevant timestamps.
    /// </summary>
    /// <param name="entry">The PersonaKnowledgeEntry record to save.</param>
    /// <returns>The saved PersonaKnowledgeEntry record.</returns>
    Task<PersonaKnowledgeEntry<TAnalysisData>> SaveAsync(PersonaKnowledgeEntry<TAnalysisData> entry);

    /// <summary>
    /// Deletes a PersonaKnowledgeEntry record by its unique ID.
    /// </summary>
    /// <param name="id">The unique ID of the knowledge entry to delete.</param>
    /// <param name="partitionKey">The partition key required for the Cosmos DB delete operation.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    Task DeleteAsync(string id, string partitionKey);

    // Potential future methods for querying based on analysis data properties or vector search
    // Task<IEnumerable<PersonaKnowledgeEntry<TAnalysisData>>> FindByAnalysisPropertyAsync(string propertyName, object value, string partitionKey);
    // Task<IEnumerable<(PersonaKnowledgeEntry<TAnalysisData> Entry, double Score)>> FindSimilarAsync(float[] embedding, int topK, string partitionKey);
}


/// <summary>
/// Represents a knowledge entry generated by a Persona's analysis of an artifact.
/// Stored in a dedicated {PersonaId}KnowledgeContainer in Cosmos DB.
/// See: ../../Docs/Architecture/04_ARCHITECTURE_DATABASE.md#4-personaidknowledgecontainer-schema
/// </summary>
/// <typeparam name="TAnalysisData">The specific type of analysis data.</typeparam>
/// <seealso cref="../../../Docs/Architecture/02_ARCHITECTURE_PERSONAS.md"/>
/// <seealso cref="../../../Docs/Architecture/04_ARCHITECTURE_DATABASE.md"/>
/// <seealso cref="../../../Docs/Architecture/Processing/ARCHITECTURE_PROCESSING_INGESTION.md"/>
public record PersonaKnowledgeEntry<TAnalysisData>
{
    /// <summary>
    /// Unique identifier for the knowledge entry within its container.
    /// </summary>
    public required string Id { get; init; }

    /// <summary>
    /// ID of the ArtifactMetadata record this knowledge entry pertains to.
    /// </summary>
    public required string ArtifactId { get; init; }

    /// <summary>
    /// ID of the Persona that generated this knowledge entry.
    /// </summary>
    public required string PersonaId { get; init; }

    /// <summary>
    /// Tenant ID associated with the original artifact.
    /// </summary>
    public required string TenantId { get; init; }

    /// <summary>
    /// User ID associated with the original artifact context.
    /// </summary>
    public required string UserId { get; init; }

    /// <summary>
    /// Timestamp when this knowledge entry was created.
    /// </summary>
    public DateTimeOffset CreatedAt { get; init; } = DateTimeOffset.UtcNow;

    /// <summary>
    /// The actual analysis data generated by the persona.
    /// </summary>
    public required TAnalysisData AnalysisData { get; init; }

    /// <summary>
    /// A summary of the analysis, potentially used for quick previews or RAG.
    /// </summary>
    public string? AnalysisSummary { get; init; }

    /// <summary>
    /// Vector embedding of the AnalysisSummary.
    /// </summary>
    public IReadOnlyList<float>? AnalysisSummaryEmbedding { get; init; }

    /// <summary>
    /// The model used to generate the AnalysisSummaryEmbedding.
    /// </summary>
    public string? AnalysisSummaryEmbeddingModel { get; init; }

    /// <summary>
    /// Relevant text snippets extracted from the artifact during analysis, with embeddings.
    /// </summary>
    public List<RelevantSnippet> RelevantTextSnippets { get; init; } = [];

    // Consider adding PartitionKey property similar to ArtifactMetadata if needed
    // public string PartitionKey => ArtifactId; // Example: Partition by ArtifactId
}

/// <summary>
/// Represents a relevant text snippet extracted by a Persona, along with its embedding.
/// </summary>
/// <seealso cref="../../../Docs/Architecture/04_ARCHITECTURE_DATABASE.md"/>
public record RelevantSnippet
{
    /// <summary>
    /// The extracted text content.
    /// </summary>
    public required string Text { get; init; }

    /// <summary>
    /// Vector embedding of the text snippet.
    /// </summary>
    public required IReadOnlyList<float> Embedding { get; init; }

    /// <summary>
    /// The model used to generate the embedding.
    /// </summary>
    public required string EmbeddingModel { get; init; }

    /// <summary>
    /// Optional: Identifier for the source location within the original artifact (e.g., page, timestamp).
    /// </summary>
    public string? SourceLocation { get; init; }
}
