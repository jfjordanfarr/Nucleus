---
title: Architecture - Storage & Metadata Management
description: Outlines the strategy for managing artifacts and metadata, emphasizing exclusive reliance on user source system storage and internal metadata persistence, orchestrated via API service reference-based interactions.
version: 1.14
date: 2025-05-14
---

# Nucleus: Storage Architecture

**Version:** 1.14
**Date:** 2024-03-09

This document outlines the architecture for managing **artifacts** and their associated **metadata** within the Nucleus system, expanding on the concepts introduced in the [System Architecture Overview](./00_ARCHITECTURE_OVERVIEW.md). A fundamental principle is that Nucleus **does not maintain its own persistent artifact storage**. Instead, it interacts with artifacts directly within the user's chosen source systems (e.g., Microsoft Teams/SharePoint, Slack, Email Servers) via platform-specific adapters (see [Client Architecture](./05_ARCHITECTURE_CLIENTS.md)), respecting existing permissions (see [Security Architecture](./06_ARCHITECTURE_SECURITY.md)). These interactions are orchestrated **exclusively by the `Nucleus.Services.Api` via `ArtifactReference` objects**. Nucleus's own persistent storage ([Cosmos DB](./04_ARCHITECTURE_DATABASE.md)) is reserved exclusively for **metadata** (`ArtifactMetadata`, `PersonaKnowledgeEntry`) derived from or describing these external artifacts.

## 1. Core Principles

*   **User Source System is Authoritative:** The original artifact (user-provided *or* Nucleus-generated) resides and is managed within the user's designated source system (SharePoint, Slack Files, Google Drive, etc.). Nucleus interacts with these systems via [adapters](./05_ARCHITECTURE_CLIENTS.md).
*   **Metadata in Nucleus DB:** Essential metadata about the source artifact (`ArtifactMetadata`) and persona-specific analysis (`PersonaKnowledgeEntry`) are stored in Nucleus's own [database layer (Cosmos DB)](./04_ARCHITECTURE_DATABASE.md). This metadata contains pointers (`sourceUri`, `sourceIdentifier`) to the actual artifact in the user's system.
*   **No Intermediate Storage:** Nucleus avoids creating its own persistent store for artifacts. Temporary, in-memory streams might be used during [processing](./01_ARCHITECTURE_PROCESSING.md), but **no intermediate persistence** (like Azure Blob Storage or dedicated file shares) is used for user content, aligning with Zero Trust principles detailed in the [Security Architecture](./06_ARCHITECTURE_SECURITY.md).
*   **Reference-Based Access:** Nucleus accesses artifacts in the source system **only** when needed for processing, using [`ArtifactReference`](../../../src/Nucleus.Abstractions/Models/ArtifactReference.cs) objects provided by clients in API requests. The API service then uses the appropriate [`IArtifactProvider`](../../../src/Nucleus.Abstractions/IArtifactProvider.cs) implementation to ephemerally fetch content stream based on the reference. Access is governed by the permissions granted to its corresponding bot or application identity within that platform (e.g., Teams bot permissions to read/write files in a channel). See [Security Architecture](./06_ARCHITECTURE_SECURITY.md).
*   **Support Diverse Sources:** The architecture must accommodate artifacts from various locations accessible via APIs (cloud drives, collaboration platforms, email attachments) through the [Client/Adapter Architecture](./05_ARCHITECTURE_CLIENTS.md), unified by the `ArtifactReference` mechanism.

## 2. Key Metadata Structure: `ArtifactMetadata`

The [`ArtifactMetadata`](../../../src/Nucleus.Abstractions/Models/ArtifactMetadata.cs) record is the central object persisted in the `ArtifactMetadataContainer` within [Cosmos DB](./04_ARCHITECTURE_DATABASE.md) for *every* unique artifact Nucleus interacts with. It represents Nucleus's understanding of the artifact's properties and context, derived primarily from the source system via [Adapters](./05_ARCHITECTURE_CLIENTS.md).

**Authoritative Definition:** The precise C# definition of the [`ArtifactMetadata`](../../../src/Nucleus.Abstractions/Models/ArtifactMetadata.cs) record resides within the codebase. Refer to the source code and its XML documentation for the exact fields and their types.

The conceptual categories of information stored within `ArtifactMetadata` include:

*   **Identification & Core:** Unique identifiers within Nucleus and the source system, location URI, system type, name, MIME type, size.

*   **Relationships & Context (`Where` / `How` Part 1):** Links to parent/container artifacts, related conversation threads, explicitly referenced artifacts, and source-specific context.

*   **Authorship & Ownership (`Who`):** Information about the creator, modifier, and owner from the source system perspective.

*   **Timestamps (`When`):** Creation, modification, ingestion, and processing timestamps.

*   **Content & Purpose (`What` / `Why` - Often Inferred/Extracted):** Content hash, text length, objective summaries or keywords (if generated by core processes), and inferred purpose tags.

*   **Generation Info (`How` Part 2 - For Nucleus-Generated Artifacts):** Details about how and why an artifact was generated by a persona, linking back to the originating request.

*   **Processing State:** Overall status and detailed per-persona processing status, including links to generated knowledge entries.

*   **Access Control:** Information related to permissions and sensitivity derived from the source system.

**(Note:** The exact fields, types, and nullability are defined in the C# source code model.)

## 3. Handling Persona-Generated Artifacts

A core principle is that Nucleus **does not manage its own persistent artifact storage layer**. This applies equally to artifacts generated *by* Personas (e.g., reports, summaries, code, data visualizations) in response to user requests.

1.  **Generation:** A Persona, operating within the context of the **API service's processing flow**, generates the content for a new artifact.
2.  **Instruction:** The Persona's logic signals the intent to save this artifact.
3.  **API Orchestration:** The **`Nucleus.Services.Api` layer** receives this instruction.
4.  **Targeting:** The API service determines the appropriate target source system (e.g., the user's default OneDrive, the current Teams channel) based on user context, configuration, or explicit instruction.
5.  **Adapter Invocation:** The API service resolves the correct Platform Adapter for the target system.
6.  **Write Operation:** The API service instructs the adapter to write the generated artifact content to the target location, providing necessary authentication context (see [Security Architecture](./06_ARCHITECTURE_SECURITY.md)). The adapter handles the platform-specific API calls.
7.  **Metadata Creation:** Upon successful write, the adapter returns details (like the new `sourceUri`, `sourceIdentifier`, timestamps) to the API service.
8.  **Persistence:** The API service uses this information to create a new `ArtifactMetadata` record in Cosmos DB, linking it to the newly generated artifact in the source system.

This approach ensures:
*   User data (including generated artifacts) remains within their managed environment.
*   Generated artifacts are discoverable and manageable using the source system's native tools.
*   Nucleus maintains a consistent metadata view across ingested and generated artifacts.

## 4. Core Operations

*   **Interaction Trigger (Ingestion/Update/Query):** When an event occurs that requires Nucleus interaction (e.g., a new artifact detected via webhook, a user query mentioning an artifact, a direct user command like `nucleus interact`):
    *   The Platform Adapter receives the trigger event from the source system or user input.
    *   The Adapter constructs an `AdapterRequest` DTO containing relevant context (user info, channel, etc.) and, crucially, one or more `ArtifactReference` objects pointing to any relevant artifacts in the user's source system.
    *   The Adapter makes an **API call** to the `Nucleus.Services.Api` (typically `POST /api/v1/interactions`), sending the `AdapterRequest` as a JSON payload. **The API does not accept direct file uploads (e.g., `multipart/form-data`).**
    *   The **API service** authenticates the request, validates the `AdapterRequest` and `ArtifactReference`s, and determines the appropriate action (e.g., initiate analysis, handle query).
    *   The **API service orchestrates** the subsequent processing pipeline (sync or async, see [Processing Architecture](./01_ARCHITECTURE_PROCESSING.md)).
    *   The pipeline logic, under API control:
        *   Interacts with the [`IArtifactMetadataRepository`](../../../src/Nucleus.Abstractions/Repositories/IArtifactMetadataRepository.cs) to manage metadata persistence (creating or updating `ArtifactMetadata`).
        *   If processing/analysis of artifact content is required:
            *   It uses the `ArtifactReference` from the initial request (or retrieved from `ArtifactMetadata`) to identify the artifact.
            *   It invokes the appropriate [`IArtifactProvider`](../../../src/Nucleus.Abstractions/IArtifactProvider.cs) (resolved by the API service based on `ReferenceType`) to ephemerally retrieve the artifact's content stream ([`ArtifactContent`](../../../src/Nucleus.Abstractions/Models/ArtifactContent.cs)).
            *   The content stream is used for analysis by the relevant [Personas](./02_ARCHITECTURE_PERSONAS.md).
        *   Updates processing status fields in the `ArtifactMetadata` document as analysis progresses.

## 5. Integration with Other Architectures

*   **Processing Pipeline (`01_ARCHITECTURE_PROCESSING.md`):**
    *   **Orchestrated by the API service**, it coordinates the steps of ingestion, analysis, and knowledge storage.
    *   Invokes `IArtifactMetadataRepository` to manage metadata persistence.
    *   Uses the `IArtifactProvider` interface **(invoked by API-controlled logic)** to ephemerally fetch artifact content based on `ArtifactReference`s when needed for analysis.

*   **Database Layer (`04_ARCHITECTURE_DATABASE.md`):**
    *   Is the primary persistence layer for `ArtifactMetadata` and `PersonaKnowledgeEntry`.
    *   Leverages Cosmos DB features for indexing (including vector indexing on embeddings within `PersonaKnowledgeEntry`), querying, and scaling.

*   **Persona Layer (`02_ARCHITECTURE_PERSONAS.md`):**
    *   Receives artifact content streams (fetched by the pipeline) for analysis.
    *   Produces `PersonaKnowledgeEntry` data (including analysis and embeddings) stored in Cosmos DB.
    *   During query handling, retrieves relevant `PersonaKnowledgeEntry` documents from Cosmos DB. May use the associated `sourceIdentifier` to request the pipeline/adapter layer to fetch fresh snippets or verify information from the original artifact via its `sourceUri` if needed.

*   **Client/Adapter Layer (`05_ARCHITECTURE_CLIENTS.md`):**
    *   Provides the concrete implementations for interacting with source systems (Graph API, Slack API, etc.) to read/write artifacts using appropriate authentication and permissions.
    *   Handles triggers/webhooks from source systems.

## 6. Security Considerations

*   **Authentication & Authorization:** Nucleus adapters must securely authenticate with source systems (e.g., OAuth for Graph API, Slack Bot Tokens). Access to artifacts is governed by the permissions granted to the Nucleus application/bot identity *within the source system*. **The `Nucleus.Services.Api` layer is responsible for managing the security context and securely providing necessary credentials/tokens to adapters when directing them to interact with source systems.**
*   **Data Minimization:** Nucleus only stores metadata in its database. The potentially sensitive content remains within the user's controlled environment.
*   **Cosmos DB Security:** Standard database security practices apply (network restrictions, access keys/RBAC, encryption at rest/transit).
*   **Secrets Management:** Securely manage API keys, OAuth client secrets, bot tokens needed by adapters (e.g., Azure Key Vault, Aspire configuration).
*   **PII/Sensitive Data:** While original content stays external, the metadata itself (`displayName`, `tags`, user IDs, context) might contain PII. Apply appropriate data handling policies.

## 7. Composite Artifact Handling

When a source artifact represents a collection (e.g., a folder, an email with multiple attachments), the `ArtifactMetadata` system uses the optional `composite...` fields in Cosmos DB to link them:

1.  A **parent** `ArtifactMetadata` document can be created for the container concept (e.g., the folder, the email itself), assigned a unique `compositeArtifactId`, and role `Parent`.
2.  **Child** `ArtifactMetadata` documents are created for each item within the container (files in folder, attachments), inheriting the same `compositeArtifactId`, linking back via `parentSourceIdentifier`, and assigned role `Child`.
3.  This allows personas, when analyzing a child artifact, to query Cosmos DB using the `compositeArtifactId` to retrieve metadata for related items, understanding the full context.

## 8. Next Steps

1.  **Implement `IArtifactMetadataRepository`:** Create a Cosmos DB implementation (likely within `Nucleus.Services.Api`) for the defined [`IArtifactMetadataRepository`](../../../src/Nucleus.Abstractions/Repositories/IArtifactMetadataRepository.cs) interface for CRUD operations on `ArtifactMetadata` documents.
2.  **Implement `IArtifactProvider`s:** Create implementations of [`IArtifactProvider`](../../../src/Nucleus.Abstractions/IArtifactProvider.cs) for initial target systems (e.g., local file system for `Nucleus.Console`, Graph API for Teams/SharePoint).
3.  **Finalize `sourceIdentifier` Strategy:** Define the precise algorithm for generating stable logical `sourceIdentifier`s for different `SourceSystemType`s, ensuring uniqueness and allowing correlation even if the `sourceUri` changes slightly (e.g., SharePoint version updates).
4.  **Integrate with Processing Pipeline:** Ensure the pipeline correctly interacts with the `IArtifactMetadataRepository` and invokes `IArtifactProvider` via the API service logic based on `ArtifactReference`s.
5.  **Develop Platform Adapters:** Build out the necessary adapters in the Client Layer (`05_ARCHITECTURE_CLIENTS.md`) for key target source systems, ensuring they correctly construct `AdapterRequest` and `ArtifactReference` objects.
6.  **Refine Metadata Schema:** Continuously refine the `ArtifactMetadata` fields based on persona needs and extraction capabilities.

---

_This architecture clarifies that Nucleus leverages user source systems for artifact storage via adapters and uses its own database (Cosmos DB) solely for persisting rich metadata (`ArtifactMetadata`) and derived persona knowledge. All interaction is API-mediated using reference-based requests._
