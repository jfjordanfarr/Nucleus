# Nucleus OmniRAG: Database Architecture (Azure Cosmos DB)

**Version:** 1.7
**Date:** 2025-04-08

This document details the simplified architecture of the backend database used by Nucleus OmniRAG, utilizing Azure Cosmos DB for NoSQL. It focuses solely on storing persona-specific analysis and associated **relevant text snippets/summaries and embeddings**, relying on the Storage Architecture for primary **artifact metadata**.

## 1. Core Principle: Persona-Centric Knowledge Stores

Cosmos DB's role is to provide highly performant, scalable, and isolated knowledge stores for *each persona*. Personas query their *own* containers to retrieve past analyses or relevant text segments based on semantic similarity. The primary metadata about ingested artifacts resides in the **`ArtifactMetadata` structure within the Storage Layer** (see `03_ARCHITECTURE_STORAGE.md`).

## 2. Database Structure

The Cosmos DB database contains multiple containers, one for each unique persona type and version.

*   **Container Naming Convention:** `{PersonaId}KnowledgeContainer` (e.g., `EduFlow_v1KnowledgeContainer`, `HealthSpecialist_v2KnowledgeContainer`).
*   **Purpose:** Each container holds all knowledge segments generated by that specific persona, including analysis, associated **relevant text snippets/summaries**, and embeddings, representing what the persona *knows* about various source artifacts or segments.

## 3. `{PersonaId}KnowledgeContainer` Schema

Each document stored within a persona-specific container follows the `PersonaKnowledgeEntry<TAnalysisData>` structure, detailed below.

*   **Document Example (`EduFlow_v1KnowledgeContainer` storing `PersonaKnowledgeEntry<EduFlowAnalysis>`):
    ```json
    {
        "id": "unique-pke-guid", // Cosmos DB Document ID for this PersonaKnowledgeEntry
        "userId": "user-guid-or-identifier",     // Partition Key (Cloud-Hosted)
        // "tenantId": "tenant-guid-or-identifier", // Partition Key Alt (Self-Hosted)
        "sourceIdentifier": "storage-uri-or-artifact-id", // Links to the ArtifactMetadata in Storage Layer
        "sourceSegmentIdentifier": "segment-0", // Optional: Identifies a specific part/segment within the source artifact
        "personaName": "EduFlow_v1", // Explicitly states the generating persona
        "relevantTextSnippetOrSummary": "EduFlow decided this text was most relevant: Learner shows understanding of algebraic equations...", // Persona-extracted/generated text snippet or summary, max length enforced!
        "snippetEmbedding": [0.12, -0.05, ...], // Vector embedding of relevantTextSnippetOrSummary
        "analysis": { // Persona-specific structured analysis object (schema varies per persona)
            // Example for EduFlowAnalysis:
            "analysisTimestamp": "2025-04-08T03:00:00Z",
            "modelVersion": "gemini-1.5-pro-latest",
            "confidenceLevel": "High", // Enum: Low, Medium, High, VeryHigh
            "summary": "Learner demonstrates proficiency in solving linear equations but struggles with quadratic formulas.",
            "suggestedSkillIds": ["skill-algebra-linear", "skill-problem-solving"],
            "potentialMisconceptions": "Confuses quadratic formula terms.",
            // ... other EduFlowAnalysis specific fields
        },
        // Optional: Embedding of a derived summary from the analysis object itself
        // "analysisSummaryEmbedding": [-0.08, 0.25, ...],
        "relatedSourceIdentifiers": ["other-storage-uri-or-id"], // Links to other ArtifactMetadata suggested by the persona
        "timestampCreated": "2025-04-08T03:05:00Z", // When this PKE was created
        "timestampLastUpdated": "2025-04-08T03:05:00Z", // When this PKE was last updated
        "_ts": 1678722600 // Cosmos DB Timestamp
    }
    ```

### 3.1 C# Model: `PersonaKnowledgeEntry<TAnalysisData>`

This generic C# record defines the structure of documents stored in the persona knowledge containers. An "entry" represents what a persona knows about a specific source or a segment of a source. Implementations will use concrete types for `TAnalysisData` based on the specific persona.

```csharp
/// <summary>
/// Defines standard confidence levels reported by personas.
/// </summary>
public enum ConfidenceLevel
{
    Unknown = 0,
    VeryLow = 1,
    Low = 2,
    Medium = 3,
    High = 4,
    VeryHigh = 5
}

/// <summary>
/// Represents a single knowledge entry stored in a
/// persona-specific Cosmos container, containing persona analysis
/// linked to a specific source artifact or segment. This captures what a persona knows about that source/segment.
/// </summary>
/// <typeparam name="TAnalysisData">The CLR type of the persona-specific analysis payload.</typeparam>
public record PersonaKnowledgeEntry<TAnalysisData>(
    string id, // Primary Key (Document ID)
    string userId, // Partition Key (Cloud-Hosted)
    string sourceIdentifier, // FK linking to ArtifactMetadata (e.g., its ID or source URI)
    string personaName, // Name/Version of the generating persona (e.g., "EduFlow_v1")
    string relevantTextSnippetOrSummary, // Persona-extracted/generated text snippet or summary
    Embedding<float> snippetEmbedding, // Embedding of the relevantTextSnippetOrSummary
    TAnalysisData analysis, // The structured analysis object specific to the persona
    DateTimeOffset timestampCreated, // When this knowledge entry was created
    DateTimeOffset timestampLastUpdated, // When the record was last updated

    string? sourceSegmentIdentifier = null, // Optional: Identifier for a specific segment within the source
    Embedding<float>? analysisSummaryEmbedding = null, // Optional: Embedding of a summary derived *from* the analysis object
    List<string>? relatedSourceIdentifiers = null, // Optional: Links to other related source artifacts
    string? tenantId = null // Optional Partition Key for Self-Hosted
)
{
    // Explicit property for Cosmos SDK partition key path mapping if needed
    public string PartitionKey => tenantId ?? userId;
}

## 4. Integration with Other Architectures

### 4.1 Processing (`01_ARCHITECTURE_PROCESSING.md`)

*   The pipeline interacts with both Storage and Cosmos DB:
    *   Reads source content based on `ArtifactMetadata` from Storage Layer.
    *   Creates/Updates the `ArtifactMetadata` in the Storage Layer (see `03_ARCHITECTURE_STORAGE.md`).
    *   Extracts raw text.
    *   For each target persona:
        *   Invokes the persona's analysis logic (`AnalyzeContentAsync`) with source info and the raw extracted text.
        *   Persona determines the `relevantTextSnippetOrSummary`.
        *   Persona generates the structured `analysis` object (of type `TAnalysisData`).
        *   Calculates `snippetEmbedding` (and optionally `analysisSummaryEmbedding`).
        *   Writes the complete `PersonaKnowledgeEntry<TAnalysisData>` record to the specific `{PersonaId}KnowledgeContainer` in Cosmos DB.
        *   Updates the `personaProcessingStatus` in the storage `ArtifactMetadata`.

### 4.2 Personas (`02_ARCHITECTURE_PERSONAS.md`)

*   **Analysis:** Personas receive source context (via `sourceIdentifier` lookup if needed), perform analysis, generate the `relevantTextSnippetOrSummary` and the structured `analysis` object.
*   **Retrieval for Querying/Reporting (RAG):**
    *   A persona queries **its own** `{PersonaId}KnowledgeContainer`.
    *   It can perform vector searches against `snippetEmbedding` (to find similar relevant text it has stored) or potentially `analysisSummaryEmbedding` (to find similar analyses it has recorded).
    *   Queries are inherently isolated to the persona's own knowledge store.
    *   Field projection should still be used to retrieve only necessary fields (`id`, `relevantTextSnippetOrSummary`, `analysis`, `sourceIdentifier`, `relatedSourceIdentifiers` etc.) depending on the task.

### 4.3 Storage (`03_ARCHITECTURE_STORAGE.md`)

*   The Storage Layer holds the primary `ArtifactMetadata` for each source.
*   Cosmos DB only stores the `sourceIdentifier` to link back to this metadata.
*   Retrieving full artifact metadata (like `displayName`) requires reading the `ArtifactMetadata` from storage.

## 5. Scalability and Performance

*   **Partitioning:** The `userId`/`tenantId` partition key ensures user data is co-located within each persona container, enabling efficient, scalable queries.
*   **Vector Search:** Dedicated vector indexes within each persona's container allow for fast, targeted similarity searches.
*   **Read/Write Isolation:** Personas operate independently on their own containers, reducing contention.
*   **Throughput:** RU/s (Request Units per second) need to be provisioned per container or using shared database throughput, considering the query patterns of each persona.

## 6. Next Steps

1.  **Implement C# Models:** Finalize the `PersonaKnowledgeEntry<T>` record, the `ConfidenceLevel` enum, and concrete `TAnalysisData` types for each persona (e.g., `EduFlowAnalysis`). Ensure `TAnalysisData` includes a `ConfidenceLevel` property.
2.  **Implement Repository Layer:** Develop a data access layer, potentially generic (`IPersonaKnowledgeRepository<TAnalysisData>`), with implementations using the Cosmos DB .NET SDK. The repository needs to handle dynamic container naming based on `personaName`.
3.  **Define and Implement Storage Interaction:** Define the `ArtifactMetadata` structure in `03_ARCHITECTURE_STORAGE.md` and implement logic to read/write it reliably.
4.  **Provision Cosmos DB:** Set up the Cosmos DB account and database. Containers will likely be created dynamically or via configuration as new persona versions are deployed.
5.  **Integrate with Processing Pipeline:** Update the pipeline to implement the flow described in Section 4.1, including persona invocation and writing to Cosmos DB.
6.  **Refactor Processing Architecture Doc:** Update `01_ARCHITECTURE_PROCESSING.md` to remove the old "chunking" paradigm and describe the persona-driven extraction/analysis flow.

---

_This architecture document specifies the simplified, persona-centric database structure, emphasizing its role in storing **persona-driven analysis, relevant text snippets/summaries, and embeddings**, while relying on the storage layer for primary source artifact metadata._
